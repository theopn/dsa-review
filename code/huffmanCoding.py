import heapq
from collections import Counter


class HuffNode:
    def __init__(self, character=None, frequency=0):
        self.character = character
        self.frequency = frequency
        self.left = None
        self.right = None

    def __gt__(self, other):
        return self.frequency > other.frequency

    def __str__(self):
        return f"{self.character}: {self.frequency}"


def buildHuffmanTree(freq: dict):
    """
    Given the dictionary of frequency of each character, build a Huffman Tree
    :return: dict of character to respective code generated by Huffman coding
    """
    min_heap = [HuffNode(char, f) for char, f in freq.items()]
    heapq.heapify(min_heap)

    while len(min_heap) > 1:
        left = heapq.heappop(min_heap)
        right = heapq.heappop(min_heap)

        mergedSubtree = HuffNode(frequency=left.frequency + right.frequency)
        mergedSubtree.left = left
        mergedSubtree.right = right

        heapq.heappush(min_heap, mergedSubtree)

    return min_heap[0]  # root


def getCodeMap(root: HuffNode):
    """
    Given the root of the Huffman Tree, create a dictionary mapping
    character to the respective code generated by the tree.
    Left nodes get 0, right nodes get 1.
    :param root: root of the Huffman Tree, generated by buildHuffmanTree()
    :return: dict of character to respective code generated by Huffman coding
    """
    codeMap = {}

    def preorder(node, code=""):
        if node is None:
            return

        if node.character is not None:
            codeMap[node.character] = code
        preorder(node.left, code=code + '0')
        preorder(node.right, code=code + '1')

    preorder(root)
    return codeMap


def encode(pattern, codeMap):
    """
    Given a string and a Huffman dictionary, encode the string
    :param pattern: String to code
    :param codeMap: dict mapping character to code, generated by getCodeMap()
    :return: coded string
    """
    return "".join([codeMap[c] for c in pattern])


def decode(pattern, root):
    """
    Given Huffman string and a Huffman tree, decode the string
    :param pattern: Huffman string to decode
    :param root: Root of the respective Huffman tree
    :return: decoded string
    """
    n = len(pattern)

    curr = root
    res = ""
    for i in range(n):
        if pattern[i] == '0':
            curr = curr.left
        else:
            curr = curr.right

        # Reached a leaf node
        # 1. if curr.character is not None
        # 2. if curr.frequency is None
        # 3. if curr.left is None and curr.right is None
        # above three are all logically same in this context,
        # as nodes in Huffman tree contains either frequency or character
        # and leaf nodes are always the ones that contain the character
        if curr.character is not None:
            res += curr.character
            curr = root  # reset to the root

    return res


def actualPreorder(node):
    if node is None:
        return

    if node.character is not None:
        print(node.character)
    actualPreorder(node.left)
    actualPreorder(node.right)


strr = "EEEEEEEEEEEEEEEEEDDDDDDDDDDCCCCCOOOAAAAAAAAAAAAAAAGGGGGG"
root = buildHuffmanTree(Counter(strr))
# root = buildHuffmanTree({"E": 17, "D": 10, "C": 5, "O": 3, "A": 15, "G": 6})
# print(getCodeMap(root))
# print(encode("GOOD", getCodeMap(root)))
print(actualPreorder(root))
print(decode("000110010", root))
